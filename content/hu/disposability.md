## IX. Eldobhatóság
### Az elérhető legnagyobb hibatűrés gyors üzembehelyezéssel és egyszerű, gördülékeny leállítással

**A tizenkét tényezős alkalmazás [folyamatai](./processes) are *eldobhatóak*,ami azt jelenti, hogy nagyjából a parancs észlelésének pillanatában képes elindulni vagy leállni.** Ez megkönnyíti a rugalmas méretezést, a [kód](./codebase) vagy [konfiguráció](./config) változásának gyors telepítését, és az üzemeltetési telepítés hibatűrését.

A folyamatoknak törekedniük kell **az üzembehelyezésükhöz szükséges idő minimalizálására**. Ideális esetben egy folyamatnak néhány másodpercig tart az indulási parancstól eljutni egészen addig, hogy a folyamat fut és kész a kérések vagy a feladatok fogadására. A gyors üzembehelyezési idő több teret biztosít a folyamat [üzembehelyezéséhez](./build-release-run) és felskálázódásához; segíti a hibatűrést, ugyanis ha indokolt, a folyamatkezelő könnyebben át tudja mozgatni a folyamatot egy új fizikai eszközre..

A folyamat **A folyamat álljon le egyszerűen és gördülékenyen, ha megkapja a [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** leállító parancsot a folyamatkezelőtől. Webes folyamatoknál ez elérhető, ha megszüntetjük a szolgáltatás portján a rendelkezésre állást (listening) - ezzel minden további kérést visszautasítva, engedélyezzük viszont a folyamatban lévő kérések teljesítését és csak ezután állítjuk le a folyamatot. Ebből következik, hogy ebben a modellben a HTTP kérések kiszolgálása rövid (nem több néhány másodpercnél), a hosszú ideig tartó hívásokkal történő folyamatos lekérdezés ([long polling](https://www.pubnub.com/blog/2014-12-01-http-long-polling/)) esetén pedig a kliens zökkenőmentesen újrakapcsolódik, ha a kapcsolat megszakad.

Munkavégző folyamatok esetén az egyszerű és gördülékeny leállás elérhető az aktuális végrehajtás alatt lévő feladat visszahelyezésével a várakozósorba. Például a [RabbitMQ](http://www.rabbitmq.com/) üzenetsor esetén a munkavégző folyamat küldhet egy  [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack) jelet; míg [Beanstalkd](http://kr.github.com/beanstalkd/) esetén a feladat automatikusan visszakerül a várakozósorba, ha a munkavégző felé megszakad a kapcsolat. A [Delayed Job](https://github.com/collectiveidea/delayed_job#readme)-hoz hasonló zárolás alapú rendszereknél fontos, hogy a zárolást ilyenkor a feladat adatrekordján feloldjuk. A modellünknek a következménye, hogy minden feladat [ismételhető](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29) kell legyen,ami tipikusan a feladatok tranzakcióba burkolásával, vagy a műveletek [idempotenssé](http://en.wikipedia.org/wiki/Idempotence) tételével (az első feladatvégzés után a további ismétlések nem változtatják az eredményt) érhető el.

A folyamatoknak ezen kívül **jól kell tűrniük a hirtelen halált is**, a futtató hardver eszköz meghibásodásának az esetét is. Bár ez a leállási parancs  (`SIGTERM`),hatására történő egyszerű és gördülékeny leállásnál sokkal ritkábban előforduló lehetőség, azért meg szokott történni. Az javasolt megközelítés egy hibatűrő üzenetsor használata, mint például a Beanstalkd, ami egyszerűen visszahelyezi a feladatot a várakozósorba, ha kapcsolat megszakad az ügyfélprogram felé vagy a kliens időtúllépésbe kerül. Akárhogy is, a tizenkét tényezős alkalmazás a nem várt és/vagy nem gördülékeny leállások kezelésére megfelelő felépítést alkalmaz. A [kizárólag összeomlásra (crash-only) tervezési mód](http://lwn.net/Articles/191059/) ezt a koncepciót jelenti [logikus végkövetkeztetésként](http://docs.couchdb.org/en/latest/intro/overview.html).


